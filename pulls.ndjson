{"pull_number":"18958","title":"CUDA: use mmvq for mul-mat-id for small batch sizes","body":"Currently for batch_sizes > 1, we immediately move to mmq which is suboptimal for small batch sizes. Bring performance of batched bench in line (previously there was a dip at n_tokens = 2)\r\n\r\nMicro-benchmark for test-backend-ops\r\n\r\n| Backend   | GGML op    | Op parameters                                                   |   TFLOPS master |   TFLOPS mmid-vec |   Speedup |\r\n|:----------|:-----------|:----------------------------------------------------------------|----------------:|------------------:|----------:|\r\n| CUDA0     | MUL_MAT_ID | type_a=q4_0,type_b=f32,n_mats=128,n_used=8,b=0,m=768,n=1,k=2048 |            4.61 |              4.62 |      1.00 |\r\n| CUDA0     | MUL_MAT_ID | type_a=q4_0,type_b=f32,n_mats=128,n_used=8,b=0,m=768,n=4,k=2048 |            2.34 |              6.13 |      2.62 |\r\n| CUDA0     | MUL_MAT_ID | type_a=q4_0,type_b=f32,n_mats=128,n_used=8,b=0,m=768,n=8,k=2048 |            4.27 |              6.83 |      1.60 |\r\n| CUDA0     | MUL_MAT_ID | type_a=q4_0,type_b=f32,n_mats=32,n_used=4,b=0,m=1792,n=1,k=2048 |            5.49 |              5.49 |      1.00 |\r\n| CUDA0     | MUL_MAT_ID | type_a=q4_0,type_b=f32,n_mats=32,n_used=4,b=0,m=1792,n=4,k=2048 |            3.37 |              6.37 |      1.89 |\r\n| CUDA0     | MUL_MAT_ID | type_a=q4_0,type_b=f32,n_mats=32,n_used=4,b=0,m=1792,n=8,k=2048 |            6.57 |              7.23 |      1.10 |\r\n\r\n","pull_head_sha":"459b75b3cd74d9dbaa70746635e697b898f95f8f","loci_pr_branch":"loci/pr-18958-mmid-vec","short_merge_base":"6ad70c5","loci_main_branch":"loci/main-6ad70c5"}
{"pull_number":"18701","title":"[WIP] ggml-opencl: op args init refactoring","body":"Refactors the OpenCL kernel argument initialization process by introducing a template helper, significantly reducing boilerplate code and improving readability.\r\n\r\n## Key Changes\r\n- Introduced `cl_set_kernel_args`: A variadic template function that automatically iterates through arguments and sets them using `clSetKernelArg`.\r\n- Type-Specific Setters: Added `cl_kernel_arg_setter` struct specializations to handle different types:\r\n  - **ggml_tensor**: Automatically extracts the OpenCL buffer (`data_device`) and calculates the offset (`offset + view_offs`), setting both as kernel arguments.\r\n  - **Arrays (ne, nb)**: Automatically unrolls `int64_t[4]` and `size_t[4]` arrays into individual scalar arguments (e.g., ne0, ne1, ne2, ne3).\r\n  - *Primitives*: Direct handling for `int`, `float`, `cl_ulong`.","pull_head_sha":"6ebbac97155b0386c018a9b3ff90bc67a5ed0dec","loci_pr_branch":"loci/pr-18701-dev-ocl-test-fix","short_merge_base":"89f10ba","loci_main_branch":"loci/main-89f10ba"}
